{
    "docs": [
        {
            "location": "/",
            "text": "Robot\n\n\n\nNetTrade has a main abstract \"Robot\" class, this class represents a trading system and/or algorithm; you can backtest or optimize any class that is driven from the \"Robot\" class or the \"IRobot\" interface with NetTrade.\n\n\nA robot can be as simple as using a few technical analysis indicators to get trading decisions, or as complicated as using ML models to get trading decisions, an external service or an API.\n\n\nAll you need to do is create a class that's driven from the \"Robot\" abstract class or for more customization from the \"IRobot\" interface, give it a name, add some robot parameters, implement the interface methods, and you will have a trading robot.\n\n\nA simple robot example:\n\n\n    [Robot(Name = \"Simple Bot\", Group = \"Sample\")]\n    public class SimpleBot : Robot\n    {\n        [Parameter(\"Volume\", DefaultValue = 1)]\n        public double Volume { get; set; }\n\n        public override void OnStart()\n        {\n        }\n\n        public override void OnBar(ISymbol symbol, int index)\n        {\n            if (symbol.Bars.Close[index] > symbol.Bars.Open[index])\n            {\n                ClosePositions(TradeType.Sell);\n\n                var buyOrderParameters = new MarketOrderParameters(symbol)\n                {\n                    Volume = Volume,\n                    TradeType = TradeType.Buy,\n                };\n\n                Trade.Execute(buyOrderParameters);\n            }\n            else if (symbol.Bars.Close[index] < symbol.Bars.Open[index])\n            {\n                ClosePositions(TradeType.Buy);\n\n                var sellOrderParameters = new MarketOrderParameters(symbol)\n                {\n                    Volume = Volume,\n                    TradeType = TradeType.Sell,\n                };\n\n                Trade.Execute(sellOrderParameters);\n            }\n        }\n\n        private void ClosePositions(TradeType tradeType)\n        {\n            foreach (var order in Trade.Orders)\n            {\n                if (order.OrderType != OrderType.Market || order.TradeType != tradeType)\n                {\n                    continue;\n                }\n\n                Trade.CloseMarketOrder(order as MarketOrder);\n            }\n        }\n    }\n\n\n\n\nThe above robot opens a buy market order whenever there is an up/bullish bar, and a sell order whenever there is a down/bearish bar. The robot closes all positions of opposite direction before opening a new one.\n\n\nAs you can see in the robot code we have a \"Volume\" parameter; this parameter value will be used for setting the volume of the orders, and the NetTrade optimizer can optimize the value of this parameter or of any other robot parameter.\n\n\nNow let's start from the first line of the robot code which is \"RobotAttribute\". There we set a name for the robot and for a group. This data can be used by your app to display a user friendly name and to categorize your robots.\n\n\nAfter that we have a robot parameter. A robot can contain as many parameters as is needed. These parameters are recognized by the NetTrade optimizer and you will be able to optimize the values for the robot parameters. You can set the min/max/step and the default values for numeric parameters.\n\n\nThe parameter type can be any .Net object, but the NetTrade default \"GridOptimizer\" can only optimize numeric (int, long, double), enum, string, TimeSpan, DateTime, and DateTimeOffset types.\n\n\nIn the case where you would want to optimize a custom type parameter, you will have to create your own optimizer based on your requirements.\n\n\nThe \"OnStart\" robot method is its initialization method. You have to input some form of an initialization code, and it will be called once when the robot \"Start\" method is called.\n\n\nThe \"OnBar\" method is called whenever a new OHLC bar opens for that specific symbol. You will get the symbol and the bar index from the method parameters. To access the bar data you can use \"symbol.Bars.Open/High/Low/Close/Volume[index]\".\n\n\nTo start a robot, you can call its \"StartAsync\" method. There are other methods such as the Stop, Pause, and Resume methods that allow you to manage the running mode of a robot.\n\n\nYou have to pass an IRobotParameters object to StartAsync; this object will have all the necessary data that is needed for the robot to operate. You can find more about this on its own page. \n\n\nImplementable Robot General Methods\n\n\nOnStart: This method is called when you call the robot \"StartAsync\" method.\n\n\nOnTick: This method is called on each new upcoming tick.\n\n\nOnTimer: This method is called every time the robot timer interval elapses. The robot class has a timer which you can start using the OnStart method and you can use a \"TimeSpane\" to set its interval value. Don't use the conventional .Net timers because it will not work on backtest/optimizer.\n\n\nOnPause: This method is called when you call the robot \"Pause\" method.\n\n\nOnResume: This method is called when you call the robot \"Resume\" method. You should only call a robot \"Resume\" method if it's in \"Paused\" mode otherwise you will get an \"InvalidOperationException\" exception.\n\n\nOnStop: This method is called when you call the robot \"Stop\" method. You should only call a robot \"Stop\" method if it's in \"Running\" or \"Paused\" modes otherwise you will get an \"InvalidOperationException\" exception.\n\n\nBacktester Event Handler Methods\n\n\nIf you start a robot in backtesting/optimization mode, the robot will use its backtester to get symbol data, and each backtester has several event handler methods that you can override to get data about the backtest operation status.\n\n\nBacktester_OnBacktestStartEvent: This method is called when the backtest operation starts.\n\n\nBacktester_OnBacktestPauseEvent: This method is called when the backtest operation is paused.\n\n\nBacktester_OnBacktestStopEvent: This method is called when the backtest operation stops or is finished.\n\n\nAccount Event Handler Methods\n\n\nFor a trading account there are some methods that you can override.\n\n\nAccount_OnMarginCallEvent: This method is called whenever you get a margin called.\n\n\nRobot Properties\n\n\nTrade: This property allows you to access the trade engine for the purpose of executing orders.\n\n\nRunningMode: The current running robot mode.\n\n\nAccount: The trading account.\n\n\nSymbols: The symbols for the robot; the robot will receive only this symbol data.\n\n\nMode: This is either a back test for backtesting and optimization, or live for live trading.\n\n\nBacktester: If you are backtesting/optimizing a robot you can access the back tester with this property.\n\n\nBacktestSettings: If you are backtesting/optimizing a robot you can access the backtest setting with this property.\n\n\nServer: The server object that is connected to the robot. It's used to get the current time or some other server-related data.\n\n\nTimer: Robot timer; with this you can start/stop/configure the timer.",
            "title": "Robot"
        },
        {
            "location": "/#implementable-robot-general-methods",
            "text": "OnStart: This method is called when you call the robot \"StartAsync\" method.  OnTick: This method is called on each new upcoming tick.  OnTimer: This method is called every time the robot timer interval elapses. The robot class has a timer which you can start using the OnStart method and you can use a \"TimeSpane\" to set its interval value. Don't use the conventional .Net timers because it will not work on backtest/optimizer.  OnPause: This method is called when you call the robot \"Pause\" method.  OnResume: This method is called when you call the robot \"Resume\" method. You should only call a robot \"Resume\" method if it's in \"Paused\" mode otherwise you will get an \"InvalidOperationException\" exception.  OnStop: This method is called when you call the robot \"Stop\" method. You should only call a robot \"Stop\" method if it's in \"Running\" or \"Paused\" modes otherwise you will get an \"InvalidOperationException\" exception.",
            "title": "Implementable Robot General Methods"
        },
        {
            "location": "/#backtester-event-handler-methods",
            "text": "If you start a robot in backtesting/optimization mode, the robot will use its backtester to get symbol data, and each backtester has several event handler methods that you can override to get data about the backtest operation status.  Backtester_OnBacktestStartEvent: This method is called when the backtest operation starts.  Backtester_OnBacktestPauseEvent: This method is called when the backtest operation is paused.  Backtester_OnBacktestStopEvent: This method is called when the backtest operation stops or is finished.",
            "title": "Backtester Event Handler Methods"
        },
        {
            "location": "/#account-event-handler-methods",
            "text": "For a trading account there are some methods that you can override.  Account_OnMarginCallEvent: This method is called whenever you get a margin called.  Robot Properties  Trade: This property allows you to access the trade engine for the purpose of executing orders.  RunningMode: The current running robot mode.  Account: The trading account.  Symbols: The symbols for the robot; the robot will receive only this symbol data.  Mode: This is either a back test for backtesting and optimization, or live for live trading.  Backtester: If you are backtesting/optimizing a robot you can access the back tester with this property.  BacktestSettings: If you are backtesting/optimizing a robot you can access the backtest setting with this property.  Server: The server object that is connected to the robot. It's used to get the current time or some other server-related data.  Timer: Robot timer; with this you can start/stop/configure the timer.",
            "title": "Account Event Handler Methods"
        },
        {
            "location": "/IRobotParameters/",
            "text": "IRobotParameters\n\n\n\nThis is the configuration object that is passed to a robot start method. The robot will use this object to know its mode (backtest or live), as well as all the necessary data it needs to operate. Below you can find the descriptions for each property of this object.\n\n\nProperties\n\n\nMode: You set it to either backtest or live. When you optimize a robot, this property value is set by an optimizer to backtest.\n\n\nSymbols: The robot symbols; these are symbols that the robot can trade and use to receive their market data.\n\n\nBacktester: In the case where you set the mode to \"Backtest\", you have to provide a backtester for the robot.\n\n\nBacktestSettings: These are the settings that will be used by the Backtester, like the start and end times.\n\n\nAccount: The trading account for the robot.\n\n\nTradeEngine: This is the trade engine that will be used by the robot. When executing an order inside your robot, you should use this trade engine.\n\n\nServer: A server object allows you to have access to some general data like the current time.\n\n\nTimer: This is the timer that will be used by the robot. You cannot use .Net built-in or any other third party timers in the backtest.\n\n\nSymbolsBacktestData: The symbols data; for each of the robot symbols you have to provide its backtest data. In live mode this property will not be used and you can ignore it.\n\n\nFor most of the above properties NetTrade has a defualt implementation. You don't have to create your own implementations unless you need to.\n\n\nThere is a default implementation of an 'IRobotParameters' interface called the 'RobotParameters' class in 'NetTrade.Models'. You can use this instead of creating your own implementation, but if your robot needs any kind of custom data then you will have to create your own implementation.\n\n\nBelow is an example of RobotParameters:\n\n\n            var startTime = data.Min(iBar => iBar.Time); // Setting backtest start/end time based on symbol available data\n            var endTime = data.Max(iBar => iBar.Time);\n\n            var robotParmeters = new RobotParameters\n            {\n                Account = new BacktestAccount(1, 1, string.Empty, 500, \"ConsoleTester\"),\n                Backtester = new OhlcBacktester { Interval = TimeSpan.FromHours(1) },\n                BacktestSettings = new BacktestSettings(startTime, endTime),\n                Mode = Mode.Backtest,\n                Server = new Server(),\n                Symbols = new List<ISymbol> { symbol },\n                SymbolsBacktestData = new List<ISymbolBacktestData> { new SymbolBacktestData(symbol, data) },\n                Timer = new DefaultTimer(),\n            };\n\n            robotParmeters.TradeEngine = new BacktestTradeEngine(robotParmeters.Server, robotParmeters.Account);\n\n            robotParmeters.Account.AddTransaction(new Transaction(10000, startTime));\n\n            robotParmeters.Backtester.OnBacktestStopEvent += Backtester_OnBacktestStopEvent;\n            robotParmeters.Backtester.OnBacktestProgressChangedEvent += Backtester_OnBacktestProgressChangedEvent;",
            "title": "IRobotParameters"
        },
        {
            "location": "/IRobotParameters/#properties",
            "text": "Mode: You set it to either backtest or live. When you optimize a robot, this property value is set by an optimizer to backtest.  Symbols: The robot symbols; these are symbols that the robot can trade and use to receive their market data.  Backtester: In the case where you set the mode to \"Backtest\", you have to provide a backtester for the robot.  BacktestSettings: These are the settings that will be used by the Backtester, like the start and end times.  Account: The trading account for the robot.  TradeEngine: This is the trade engine that will be used by the robot. When executing an order inside your robot, you should use this trade engine.  Server: A server object allows you to have access to some general data like the current time.  Timer: This is the timer that will be used by the robot. You cannot use .Net built-in or any other third party timers in the backtest.  SymbolsBacktestData: The symbols data; for each of the robot symbols you have to provide its backtest data. In live mode this property will not be used and you can ignore it.  For most of the above properties NetTrade has a defualt implementation. You don't have to create your own implementations unless you need to.  There is a default implementation of an 'IRobotParameters' interface called the 'RobotParameters' class in 'NetTrade.Models'. You can use this instead of creating your own implementation, but if your robot needs any kind of custom data then you will have to create your own implementation.  Below is an example of RobotParameters:              var startTime = data.Min(iBar => iBar.Time); // Setting backtest start/end time based on symbol available data\n            var endTime = data.Max(iBar => iBar.Time);\n\n            var robotParmeters = new RobotParameters\n            {\n                Account = new BacktestAccount(1, 1, string.Empty, 500, \"ConsoleTester\"),\n                Backtester = new OhlcBacktester { Interval = TimeSpan.FromHours(1) },\n                BacktestSettings = new BacktestSettings(startTime, endTime),\n                Mode = Mode.Backtest,\n                Server = new Server(),\n                Symbols = new List<ISymbol> { symbol },\n                SymbolsBacktestData = new List<ISymbolBacktestData> { new SymbolBacktestData(symbol, data) },\n                Timer = new DefaultTimer(),\n            };\n\n            robotParmeters.TradeEngine = new BacktestTradeEngine(robotParmeters.Server, robotParmeters.Account);\n\n            robotParmeters.Account.AddTransaction(new Transaction(10000, startTime));\n\n            robotParmeters.Backtester.OnBacktestStopEvent += Backtester_OnBacktestStopEvent;\n            robotParmeters.Backtester.OnBacktestProgressChangedEvent += Backtester_OnBacktestProgressChangedEvent;",
            "title": "Properties"
        },
        {
            "location": "/Backtesting/",
            "text": "Backtesting\n\n\n\nOne of the main features of NetTrade is that it allows you to easily backtest a NetTrade robot. In order to backtest a NetTrade robot you have to create a backtester or use one of the available default backtesters in NetTrade.\n\n\nTo create a backtester you have to implement the \"IBacktester\" interface or the \"Backtester\" abstract class.\n\n\nNetTrade comes with a default backtester called \"OhlcBacktester\"; this backtester allows you to backtest a robot on OHLC bars data. It's a very simple backtester that feeds each symbol bar to your robot.\n\n\nOhlcBacktester code:\n\n\n    public class OhlcBacktester : Backtester\n    {\n        protected override async Task StartDataFeed()\n        {\n            var startTime = Settings.StartTime;\n            var endTime = Settings.EndTime;\n            var interval = Interval;\n\n            for (var currentTime = startTime; currentTime <= endTime; currentTime = currentTime.Add(interval))\n            {\n                bool shouldContinueDataFeed = await ShouldContinueDataFeed();\n\n                if (!shouldContinueDataFeed)\n                {\n                    break;\n                }\n\n                Robot.SetTimeByBacktester(this, currentTime);\n\n                foreach (var symbolData in SymbolsData)\n                {\n                    var bar = symbolData.GetBar(currentTime);\n\n                    if (bar != null)\n                    {\n                        (symbolData.Symbol as OhlcSymbol).PublishBar(bar);\n                    }\n                }\n\n                InvokeOnBacktestProgressChangedEvent(currentTime);\n            }\n\n            InvokeOnBacktestStopEvent();\n        }\n    }\n\n\n\n\nUsage:\n\n\n        private async static void Backtest(ISymbol symbol, IEnumerable<IBar> data)\n        {\n            var startTime = data.Min(iBar => iBar.Time);\n            var endTime = data.Max(iBar => iBar.Time);\n\n            var robotParmeters = new RobotParameters\n            {\n                Account = new BacktestAccount(1, 1, string.Empty, 500, \"ConsoleTester\"),\n                Backtester = new OhlcBacktester { Interval = TimeSpan.FromHours(1) },\n                BacktestSettings = new BacktestSettings(startTime, endTime),\n                Mode = Mode.Backtest,\n                Server = new Server(),\n                Symbols = new List<ISymbol> { symbol },\n                SymbolsBacktestData = new List<ISymbolBacktestData> { new SymbolBacktestData(symbol, data) },\n                Timer = new DefaultTimer(),\n            };\n\n            robotParmeters.TradeEngine = new BacktestTradeEngine(robotParmeters.Server, robotParmeters.Account);\n\n            robotParmeters.Account.AddTransaction(new Transaction(10000, startTime));\n\n            robotParmeters.Backtester.OnBacktestStopEvent += Backtester_OnBacktestStopEvent;\n            robotParmeters.Backtester.OnBacktestProgressChangedEvent += Backtester_OnBacktestProgressChangedEvent;\n\n            var robot = new SingleSymbolMaCrossOverBot();\n\n            await robot.StartAsync(robotParmeters); // As the robot mode is set to \"Backtest\", when you start the robot it starts the backtester\n        }\n\n\n\n\nAs you can see you have to provide IBacktestSettings to the backtester. This object will contain some data that is needed for the backtester to operate, for example the start and end times.\n\n\nThere is a simple default implementation for this at \"NetTrade.Models\" called \"BacktestSettings\".\n\n\nTo create your own backtester you should use a \"Backtester\" abstract class instead of the \"IBacktester\" interface. You should only use the \"IBacktester\" interface if you wish to make some major changes.\n\n\nIBacktester Properties\n\n\nRobot: The robot that is currenly under backtest.\n\n\nInterval: The time interval for the backtester; this is the amount of time taken between each backtester loop iteration.\n\n\nSettings: The current backtester settings.\n\n\nSymbolsData: The symbols data for the backtester.\n\n\nIBacktester Events\n\n\nOnBacktestStartEvent: This event is triggered after you call the backtester StartAsync method.\n\n\nOnBacktestPauseEvent: This event is triggered when you pause the backtester.\n\n\nOnBacktestStopEvent: This event is triggered when you stop the backtester.\n\n\nOnBacktestProgressChangedEvent: This event is triggered after each loop iteration, based on the defined time interval.\n\n\nIBacktester Methods\n\n\nStartAsync: To start the backtester you have to call this method. It requires three parameters: the first one is the robot that you want to backtest, the second one is the backtest settings object, and the third one is the symbols data.\n\n\nGetResult: Once the backtest is finished you can call this method to get the backtest statistics.",
            "title": "Backtesting"
        },
        {
            "location": "/Backtesting/#ibacktester-properties",
            "text": "Robot: The robot that is currenly under backtest.  Interval: The time interval for the backtester; this is the amount of time taken between each backtester loop iteration.  Settings: The current backtester settings.  SymbolsData: The symbols data for the backtester.  IBacktester Events  OnBacktestStartEvent: This event is triggered after you call the backtester StartAsync method.  OnBacktestPauseEvent: This event is triggered when you pause the backtester.  OnBacktestStopEvent: This event is triggered when you stop the backtester.  OnBacktestProgressChangedEvent: This event is triggered after each loop iteration, based on the defined time interval.",
            "title": "IBacktester Properties"
        },
        {
            "location": "/Backtesting/#ibacktester-methods",
            "text": "StartAsync: To start the backtester you have to call this method. It requires three parameters: the first one is the robot that you want to backtest, the second one is the backtest settings object, and the third one is the symbols data.  GetResult: Once the backtest is finished you can call this method to get the backtest statistics.",
            "title": "IBacktester Methods"
        },
        {
            "location": "/Optimization/",
            "text": "Optimization\n\n\n\nNetTrade allows you to optimize your robot parameters. The way this works is that when you define the parameters for your robot the optimizer discovers these parameters and allows you to set the minimum/maximum/step values for each parameter. The optimizer will then run a backtest for all the possible combinations of the parameter values. You will receive each optimization pass after completion by subscribing to the optimizer \"OnOptimizationPassCompletionEvent\".\n\n\nThe backtester NetTrade has a default optimizer called \"GridOptimizer\". This optimizer runs a backtest for all the possible combinations of the defined parameter values of your robot. In a case where you would want to use any other type of an optimization algorithm, you have to create your own optimizer. The optimizer classes must implement either the abstract \"Optimizer\" class or the \"IOptimizer\" interface.\n\n\nThe optimizer only allows you to optimize a specific number of parameters, not all of them.\n\n\nBelow is a code example of using the default NetTrade \"GridOptimizer\" to optimize \"SingleSymbolMaCrossOverBot\" moving average period parameters:\n\n\n        private static void Optimize(ISymbol symbol, IEnumerable<IBar> data)\n        {\n            var startTime = data.Min(iBar => iBar.Time);\n            var endTime = data.Max(iBar => iBar.Time);\n\n            var symbolsData = new List<ISymbolBacktestData> { new SymbolBacktestData(symbol, data) };\n\n            var optimizerSettings = new OptimizerSettings\n            {\n                AccountBalance = 10000,\n                AccountLeverage = 500,\n                BacktesterType = typeof(OhlcBacktester),\n                BacktestSettingsType = typeof(BacktestSettings),\n                BacktesterInterval = TimeSpan.FromHours(1),\n            };\n\n            optimizerSettings.SymbolsData = symbolsData;\n            optimizerSettings.BacktestSettingsParameters = new List<object>\n            {\n                startTime,\n                endTime,\n            }.ToArray();\n            optimizerSettings.TradeEngineType = typeof(BacktestTradeEngine);\n            optimizerSettings.TimerType = typeof(DefaultTimer);\n            optimizerSettings.ServerType = typeof(Server);\n            optimizerSettings.RobotSettingsType = typeof(RobotParameters);\n            optimizerSettings.RobotType = typeof(SingleSymbolMaCrossOverBot);\n            optimizerSettings.Parameters = new List<OptimizeParameter>()\n            {\n                new OptimizeParameter(\"Fast MA Period\", 5, 15, 5),\n                new OptimizeParameter(\"Slow MA Period\", 20),\n                new OptimizeParameter(\"Volume\", 1)\n            };\n\n            var optimizer = new GridOptimizer(optimizerSettings);\n\n            optimizer.OnOptimizationPassCompletionEvent += Optimizer_OnOptimizationPassCompletionEvent;\n            optimizer.OnOptimizationStoppedEvent += Optimizer_OnOptimizationStoppedEvent;\n            optimizer.OnOptimizationStartedEvent += Optimizer_OnOptimizationStartedEvent;\n\n            optimizer.Start();\n        }\n\n\n\n\n\nAs you can see the optimizer requires an \"IOptimizerSettings\" object. This object will inform the optimizer which robot to optimize, which parameters and which backtester to use, as well as all the other necessary data that is required by the optimizer to operate.\n\n\nThere is a default implementation of the \"IOptimizerSettings\" interface called \"OptimizerSettings\" in the NetTrade models. You can use this implementation for \"GridOptimizer\" as can be seen in the code example, but if you create any other custom optimizers you can either use these or create a new implementation of \"IOptimizerSettings\" based on your optimizer needs.\n\n\nIOptimizerSettings Properties\n\n\nSymbolsData: The symbols data that will be used for optimization. As in backtesting you have to provide the symbols data.\n\n\nRobotType: The type of robot that you want to optimize.\n\n\nRobotSettingsType: This is the \"IRobotParameters\" class type that will be used to start your robot.\n\n\nRobotSettingsParameters: The default \"IRobotParameters\" constructor parameters. If the constructor does not require any parameters you can ignore this property.\n\n\nBacktesterType: The type of backtester that will be used for optimization.\n\n\nBacktesterParameters: The default \"Backtester\" constructor parameters. If the constructor does not require any parameters you can ignore this property.\n\n\nBacktestSettingsType: The type of \"IBacktestSettings\" that will be used for starting the backtester.\n\n\nBacktestSettingsParameters: The default \"IBacktestSettings\" constructor parameters. If the constructor does not require any parameters you can ignore this property. The default \"BacktetsSettings\" class requires a start and an end time of the backtest.\n\n\nBacktesterInterval: The backtester interval.\n\n\nTradeEngineType: The type of trade engine that will be used.\n\n\nTradeEngineParameters: The trade engine constructor parameters. If there are no parameters then you can ignore this property.\n\n\nAccountBalance: The initial trading account balance.\n\n\nAccountLeverage: The trading account leverage.\n\n\nParameters: The robot parameters that you can optimize. For each parameter you have to create an \"IOptimizeParameter\". The min/max values of \"IOptimizeParameter\" must either match or be lower than the parameters attributed to the min/max values.\n\n\nServerType: The type of \"IServer\" class that will be used for the robot.\n\n\nServerParameters: The \"IServer\" class constructor parameters, if there are any.\n\n\nTimerType: The robot \"ITimer\" class type.\n\n\nTimerParameters: The \"ITimer\" class constructor parameters, if there are any.\n\n\nMaxProcessorNumber: The maximum number of CPU processors that will be used for optimization. If you don't set any value then all processors will be used.\n\n\nOnce you create an \"IOptimizerSettings\" object, all you have to do is pass it to the optimizer constructor after which you can start your optimization.\n\n\nBefore starting your optimization be sure to assign a handler for the optimizer \"OnOptimizationPassCompletionEvent\" event. After each finished backtest or pass that event will be triggered and you will be able to handle it and check the backtest statistics.\n\n\nOptimizeParameter\n\n\nThis is the NetTrade default implementation for the \"IOptimizeParameter\" interface. It has several constructors which allow you to use it based on your parameter types.\n\n\nIt has three numeric constructors for \"int, long, and double\" parameter types, a constructor for \"DateTimeOffset\" parameters, a constructor for \"TimeSpan\" parameters, and another constructor for parameters that cannot fit all the previous constructs. For the last constructor you have to provide the parameter values manually.\n\n\nIf the default \"OptimizeParameter\" class does not fulfill your requirements, you can always create your own implementation for the \"IOptimizeParameter\" interface.",
            "title": "Optimization"
        },
        {
            "location": "/Optimization/#ioptimizersettings-properties",
            "text": "SymbolsData: The symbols data that will be used for optimization. As in backtesting you have to provide the symbols data.  RobotType: The type of robot that you want to optimize.  RobotSettingsType: This is the \"IRobotParameters\" class type that will be used to start your robot.  RobotSettingsParameters: The default \"IRobotParameters\" constructor parameters. If the constructor does not require any parameters you can ignore this property.  BacktesterType: The type of backtester that will be used for optimization.  BacktesterParameters: The default \"Backtester\" constructor parameters. If the constructor does not require any parameters you can ignore this property.  BacktestSettingsType: The type of \"IBacktestSettings\" that will be used for starting the backtester.  BacktestSettingsParameters: The default \"IBacktestSettings\" constructor parameters. If the constructor does not require any parameters you can ignore this property. The default \"BacktetsSettings\" class requires a start and an end time of the backtest.  BacktesterInterval: The backtester interval.  TradeEngineType: The type of trade engine that will be used.  TradeEngineParameters: The trade engine constructor parameters. If there are no parameters then you can ignore this property.  AccountBalance: The initial trading account balance.  AccountLeverage: The trading account leverage.  Parameters: The robot parameters that you can optimize. For each parameter you have to create an \"IOptimizeParameter\". The min/max values of \"IOptimizeParameter\" must either match or be lower than the parameters attributed to the min/max values.  ServerType: The type of \"IServer\" class that will be used for the robot.  ServerParameters: The \"IServer\" class constructor parameters, if there are any.  TimerType: The robot \"ITimer\" class type.  TimerParameters: The \"ITimer\" class constructor parameters, if there are any.  MaxProcessorNumber: The maximum number of CPU processors that will be used for optimization. If you don't set any value then all processors will be used.  Once you create an \"IOptimizerSettings\" object, all you have to do is pass it to the optimizer constructor after which you can start your optimization.  Before starting your optimization be sure to assign a handler for the optimizer \"OnOptimizationPassCompletionEvent\" event. After each finished backtest or pass that event will be triggered and you will be able to handle it and check the backtest statistics.",
            "title": "IOptimizerSettings Properties"
        },
        {
            "location": "/Optimization/#optimizeparameter",
            "text": "This is the NetTrade default implementation for the \"IOptimizeParameter\" interface. It has several constructors which allow you to use it based on your parameter types.  It has three numeric constructors for \"int, long, and double\" parameter types, a constructor for \"DateTimeOffset\" parameters, a constructor for \"TimeSpan\" parameters, and another constructor for parameters that cannot fit all the previous constructs. For the last constructor you have to provide the parameter values manually.  If the default \"OptimizeParameter\" class does not fulfill your requirements, you can always create your own implementation for the \"IOptimizeParameter\" interface.",
            "title": "OptimizeParameter"
        },
        {
            "location": "/Indicators/",
            "text": "Indicators\n\n\n\nTechnical indicators are very important for algo trading, and NetTrade allows you to develop indicators and use them on your NetTrade robots. It comes with several built-in indicators that you can use to learn about how to develop an indicator based on the functions provided by NetTrade.\n\n\nYou can find the built-in indicators inside the NetTrade indicators directory. Below is an example of a simple moving average indicator:\n\n\n    public class SimpleMovingAverage : Indicator\n    {\n        private readonly ExpandableSeries<double> _data = new ExpandableSeries<double>();\n\n        public SimpleMovingAverage(ISymbol symbol)\n        {\n            Symbol = symbol;\n\n            Symbol.IndicatorOnBarEvent += Symbol_OnBarEvent;\n        }\n\n        public ISymbol Symbol { get; }\n\n        public int Periods { get; set; } = 14;\n\n        public DataSourceType DataSourceType { get; set; } = DataSourceType.Close;\n\n        public ISeries<double> Data => _data;\n\n        private void Symbol_OnBarEvent(object sender, int index)\n        {\n            var symbolData = Symbol.Bars.GetData(DataSourceType);\n\n            var dataPoint = double.NaN;\n\n            if (symbolData.Count >= Periods)\n            {\n                var dataWindow = symbolData.Skip(symbolData.Count - Periods);\n\n                dataPoint = dataWindow.Sum() / dataWindow.Count();\n            }\n\n            _data.Add(dataPoint);\n\n            OnNewValue(index);\n        }\n    }\n\n\n\n\n\nAs you can see all the indicators must be implemented in the \"IIndicator\" interface or in the \"Indicator\" abstract class.\n\n\nYou can use one indicator inside another indicator; \"Average True Range\" is a good example:\n\n\n    public class AverageTrueRange : Indicator\n    {\n        private readonly TrueRange _trueRange;\n\n        private readonly ExpandableSeries<double> _data = new ExpandableSeries<double>();\n\n        public AverageTrueRange(ISymbol symbol)\n        {\n            Symbol = symbol;\n\n            _trueRange = new TrueRange(Symbol);\n\n            _trueRange.OnNewValueEvent += _trueRange_OnNewValueEvent;\n        }\n\n        public int Periods { get; set; } = 14;\n\n        public ISymbol Symbol { get; }\n\n        public ISeries<double> Data => _data;\n\n        private void _trueRange_OnNewValueEvent(object sender, int index)\n        {\n            var dataPoint = double.NaN;\n\n            if (index + 1 >= Periods)\n            {\n                var dataWindow = _trueRange.Data.Skip(_trueRange.Data.Count - Periods);\n\n                dataPoint = dataWindow.Sum() / dataWindow.Count();\n            }\n\n            _data.Add(dataPoint);\n\n            OnNewValue(index);\n        }\n    }\n\n\n\n\n\nInside \"Average True Range\" we have used the \"True Range\" indicator.",
            "title": "Indicators"
        },
        {
            "location": "/Symbol/",
            "text": "Symbol\n\n\n\nA symbol is an asset that you can trade in NetTrade. Each symbol can have different settings based on the real asset. NetTrade came with a default \"OhlcSymbol\" implementation of the \"ISymbol\" interface, but you can also create your own implementation and use it instead, according to your requirements.\n\n\nISymbol Properties\n\n\nName: A symbol code name, for example EURUSD or AAPL.\n\n\nTickSize: The tick size of a symbol in its price term. For EURUSD it's 0.00001 or for Stocks it's one cent or 0.01.\n\n\nTickValue: The monetary value of one symbol tick movement, or how much it will cost if you trade one unit of symbol volume, as seen by the price moving by one tick.\n\n\nCommission: The amount of commission your broker charges you upon opening or closing a position.\n\n\nDigits: The number of decimal digit points in the symbol price. For EURUSD it's 5 or for Stocks it's 2.\n\n\nMinVolume: The minimum volume that your broker allows you to trade for the symbol, for EURUSD it's 1000 unit (0.01 lots).\n\n\nMaxVolume: The maximum volume that your broker allows you to trade for the symbol.\n\n\nVolumeStep: The step or interval that your broker allows you to increase or decrease in terms of volume.\n\n\nVolumeUnitValue: One volume unit of monetary vlaue.\n\n\nBid: The latest bid price of the symbol.\n\n\nAsk: The lastest ask price of the symbol.\n\n\nBars: The price data of the symbol OHLC.\n\n\nSlippage: The slippage symbol; this will only be used for the backtest.\n\n\nSpread: The current spread of the symbol.\n\n\nISymbol Events\n\n\nRobotOnTickEvent: This event is used by the robots. It is triggered whenever the symbol price changes by one tick.\n\n\nIndicatorOnTickEvent: Similar to the RobotOnTickEvent, but this is used by indicators and it is triggered before the RobotOnTickEvent.\n\n\nRobotOnBarEvent: This event is used by the robots. It is triggered whenever a new OHLC bar opens.\n\n\nIndicatorOnBarEvent: Similar to the RobotOnBarEvent, but this is used by indicators and it is triggered before the RobotOnBarEvent.\n\n\nISymbol Methods\n\n\nGetPrice: You can use this method to get the price of a symbol based on the trade type. For buy orders it returns the ask price and for sell orders it returns the bid price.\n\n\nOhlcSymbol Methods\n\n\nPublishBar: This method is used to publish a new OHLC price bar for the symbol. It adds the bar to the symbol Bars data collection and triggers the symbol OnTick and OnBar events.\n\n\nSymbol objects must be cloneable.",
            "title": "Symbol"
        },
        {
            "location": "/Symbol/#isymbol-properties",
            "text": "Name: A symbol code name, for example EURUSD or AAPL.  TickSize: The tick size of a symbol in its price term. For EURUSD it's 0.00001 or for Stocks it's one cent or 0.01.  TickValue: The monetary value of one symbol tick movement, or how much it will cost if you trade one unit of symbol volume, as seen by the price moving by one tick.  Commission: The amount of commission your broker charges you upon opening or closing a position.  Digits: The number of decimal digit points in the symbol price. For EURUSD it's 5 or for Stocks it's 2.  MinVolume: The minimum volume that your broker allows you to trade for the symbol, for EURUSD it's 1000 unit (0.01 lots).  MaxVolume: The maximum volume that your broker allows you to trade for the symbol.  VolumeStep: The step or interval that your broker allows you to increase or decrease in terms of volume.  VolumeUnitValue: One volume unit of monetary vlaue.  Bid: The latest bid price of the symbol.  Ask: The lastest ask price of the symbol.  Bars: The price data of the symbol OHLC.  Slippage: The slippage symbol; this will only be used for the backtest.  Spread: The current spread of the symbol.",
            "title": "ISymbol Properties"
        },
        {
            "location": "/Symbol/#isymbol-events",
            "text": "RobotOnTickEvent: This event is used by the robots. It is triggered whenever the symbol price changes by one tick.  IndicatorOnTickEvent: Similar to the RobotOnTickEvent, but this is used by indicators and it is triggered before the RobotOnTickEvent.  RobotOnBarEvent: This event is used by the robots. It is triggered whenever a new OHLC bar opens.  IndicatorOnBarEvent: Similar to the RobotOnBarEvent, but this is used by indicators and it is triggered before the RobotOnBarEvent.",
            "title": "ISymbol Events"
        },
        {
            "location": "/Symbol/#isymbol-methods",
            "text": "GetPrice: You can use this method to get the price of a symbol based on the trade type. For buy orders it returns the ask price and for sell orders it returns the bid price.",
            "title": "ISymbol Methods"
        },
        {
            "location": "/Symbol/#ohlcsymbol-methods",
            "text": "PublishBar: This method is used to publish a new OHLC price bar for the symbol. It adds the bar to the symbol Bars data collection and triggers the symbol OnTick and OnBar events.  Symbol objects must be cloneable.",
            "title": "OhlcSymbol Methods"
        },
        {
            "location": "/Bars/",
            "text": "Bars\n\n\n\nThis is the object that allows you to access a symbol OHLC bars data. It's used by the \"ISymbol\" interface. You have to use the NetTrade \"IBars\" interface or the \"Bars\" abstract class to create your own \"Bars\" class or use the default implementations of \"IBars\" such as \"TimeBasedBars\" which are included in NetTrade.\n\n\nYou can use \"TimeBasedBars\" for normal OHLC data, but for tick-based ones such as Renko, Range, or any other bars type you will have to create your own implementations.\n\n\nIBars Properties\n\n\nTime: Contains the bars open times data.\n\n\nOpen: Contains the bars open prices data.\n\n\nHigh: Contains the bars high prices data.\n\n\nLow: Contains the bars low prices data.\n\n\nVolume: Contains the bars volume data.\n\n\nYou can access each bar data with its index; you will receive the index via an OnBar event.\n\n\nIBars Methods\n\n\nAddBar: Adds a new bar data to the collections and returns back to the bar index.\n\n\nGetData: Returns bar-based data on your given \"DataSourceType\".\n\n\nTimeBasedBars Properties\n\n\nTimeFrame: The time frame of bars.",
            "title": "Bars"
        },
        {
            "location": "/Bars/#ibars-properties",
            "text": "Time: Contains the bars open times data.  Open: Contains the bars open prices data.  High: Contains the bars high prices data.  Low: Contains the bars low prices data.  Volume: Contains the bars volume data.  You can access each bar data with its index; you will receive the index via an OnBar event.",
            "title": "IBars Properties"
        },
        {
            "location": "/Bars/#ibars-methods",
            "text": "AddBar: Adds a new bar data to the collections and returns back to the bar index.  GetData: Returns bar-based data on your given \"DataSourceType\".  TimeBasedBars Properties  TimeFrame: The time frame of bars.",
            "title": "IBars Methods"
        },
        {
            "location": "/TradeEngine/",
            "text": "TradeEngine\n\n\n\nA trade engine is the object that will be used by the robot to execute orders. A trade engine can be created to simulate the market like the NetTrade default \"BacktestTradeEngine\", or it can be connected to a brokerage API to execute your orders on the real market.\n\n\nNetTrade allows you to easily switch between simulation and the real market by using its \"ITradeEngine\" interface. You just have to change the trade engine from simulation to a real market trade engine and everything will be managed by NetTrade itself.\n\n\nFor backtesting or optimization you can use NetTrade \"BacktestTradeEngine\", but for live trading you will have create your own trade engine class either by implementing the \"ITradeEngine\" interface or a \"TradeEngine\" abstract class.\n\n\nIf the \"BacktestTradeEngine\" does not meet your requirements you can create your own simulation trade engine or extend it.\n\n\nITradeEngine Properties\n\n\nOrders: This collection contains all of your open orders.\n\n\nTrades: This collection contains your historical trades, or closed market orders.\n\n\nJournal: This collection contains all of your trading activities.\n\n\nServer: This is the \"IServer\" object that is used on your Robot; it must be the same object.\n\n\nAccount: This is the trading account that is connected to your Robot.\n\n\nITradeEngine Methods\n\n\nExecute: With this method you can execute an order. You have to pass an \"IOrderParameters\" object; you can use the default implementations such as \"MarketOrderParameters\" and \"PendingOrderParameters\", or you can create your own implementations. It returns a TradeResult object which you can use to check if your order has been successfully executed or not.\n\n\nUpdateSymbolOrders: Whenever a symbol price changes this method must be called. The trade engine will update the symbol open orders data.\n\n\nCloseMarketOrder:  This closes a market order. It has two overrides, the default close reason is manual, while the other one allows you to specify the close reason.\n\n\nCloseAllMarketOrders: This method closes all open market orders. It has 4 overrides which allow you to set the orders trade type and the close reason.\n\n\nCancelPendingOrder: Cancels a pending order.\n\n\nWhen you are creating a trade engine all of the above methods and properties must work properly.",
            "title": "TradeEngine"
        },
        {
            "location": "/TradeEngine/#itradeengine-properties",
            "text": "Orders: This collection contains all of your open orders.  Trades: This collection contains your historical trades, or closed market orders.  Journal: This collection contains all of your trading activities.  Server: This is the \"IServer\" object that is used on your Robot; it must be the same object.  Account: This is the trading account that is connected to your Robot.",
            "title": "ITradeEngine Properties"
        },
        {
            "location": "/TradeEngine/#itradeengine-methods",
            "text": "Execute: With this method you can execute an order. You have to pass an \"IOrderParameters\" object; you can use the default implementations such as \"MarketOrderParameters\" and \"PendingOrderParameters\", or you can create your own implementations. It returns a TradeResult object which you can use to check if your order has been successfully executed or not.  UpdateSymbolOrders: Whenever a symbol price changes this method must be called. The trade engine will update the symbol open orders data.  CloseMarketOrder:  This closes a market order. It has two overrides, the default close reason is manual, while the other one allows you to specify the close reason.  CloseAllMarketOrders: This method closes all open market orders. It has 4 overrides which allow you to set the orders trade type and the close reason.  CancelPendingOrder: Cancels a pending order.  When you are creating a trade engine all of the above methods and properties must work properly.",
            "title": "ITradeEngine Methods"
        }
    ]
}